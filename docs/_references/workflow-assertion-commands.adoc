---
layout: default
title: Workflow & Assertion Commands Reference
nav_order: 3
description: "Complete reference for workflow commands (control flow, state management) and assertion commands (validation) in Pilaf"
parent: Command Reference
permalink: /reference/workflow-assertion-commands/
---

== Workflow & Assertion Commands Reference

[.lead]
Workflow and assertion commands are framework-level primitives for controlling test flow, managing state, and validating results. These commands cannot be accomplished with normal Minecraft commands.

== Overview

Pilaf provides primitive commands for testing framework operations:

* **Control Flow**: Wait, health checks
* **State Management**: Store, compare, and analyze test state
* **Data Extraction**: JSONPath queries and data filtering
* **Validation**: Comprehensive assertion types for all test scenarios

[NOTE]
====
**Framework Primitives vs. Minecraft Commands**

These are framework-level primitives that cannot be done with Minecraft commands:
- `WAIT` - System-level wait, not a game command
- `STORE_STATE` / `COMPARE_STATES` - Framework state management
- `ASSERT_*` - Test validation primitives

For game operations, use `SERVER_COMMAND` or `PLAYER_COMMAND` with Minecraft syntax.
====

=== Command Categories

[cols="2,3"]
|===
|Category |Purpose

|Workflow Commands
|Control test execution and manage state

|Assertion Commands
|Validate expected outcomes and conditions
|===

'''

=== Workflow Commands

[[wait]]
=== WAIT

[.lead]
Pause test execution for a specified duration. Essential for waiting for server responses, entity spawns, or any asynchronous operation.

==== Syntax

[source,yaml]
----
- action: "WAIT"
  id: "unique_step_id"              # <1>
  name: "Human-readable name"       # <2>
  duration: 5000                    # <3>
----

<1> Step ID for output referencing (optional)
<2> Descriptive name for logging (optional)
<3> Duration in milliseconds (required)

==== Parameters

[cols="1,1,2,3"]
|===
|Parameter |Type |Required |Description

|`action`
|string
|Yes
|Must be `"WAIT"`

|`id`
|string
|No
|Step identifier for output referencing

|`name`
|string
|No
|Human-readable description

|`duration`
|number
|Yes
|Pause duration in milliseconds
|===

==== Outputs

[cols="1,2,3"]
|===
|Output |Type |Description

|`result`
|string
|Status message (e.g., "Waited for 5000ms")

|`status`
|string
|`"success"` if wait completed

|`duration`
|number
|Actual duration waited in milliseconds
|===

==== Time Reference

[cols="1,2"]
|===
|Value |Description

|`1000`
|1 second

|`5000`
|5 seconds

|`60000`
|1 minute

|`300000`
|5 minutes

|`600000`
|10 minutes
|===

==== Example

[source,yaml]
----
# Wait for server startup
- action: "CHECK_SERVICE_HEALTH"
  id: "health_check"
  name: "Check server health"

# Wait 5 seconds for server to be ready
- action: "WAIT"
  name: "Wait for server startup"
  duration: 5000

# Wait for player connection
- action: "CONNECT_PLAYER"
  name: "Connect test player"
  player: "pilaf_tester"

# Wait for entity spawn
- action: "SERVER_COMMAND"
  id: "spawn_zombie"
  name: "Spawn zombie"
  command: "summon zombie ~ ~ ~ {CustomName:'\"test_zombie\"'}"

- action: "WAIT"
  name: "Wait for entity to spawn"
  duration: 2000
----

==== Related Commands

* link:../server-commands.html#check_service_health[CHECK_SERVICE_HEALTH] - Check service availability

'''

[[store_state]]
=== STORE_STATE

[.lead]
Store the result of an action for later comparison or reference. Essential for state comparison tests where you capture a "before" state and compare it with an "after" state.

==== Syntax

[source,yaml]
----
- action: "STORE_STATE"
  id: "unique_step_id"              # <1>
  name: "Human-readable name"       # <2>
  sourceVariable: "${{ steps.step_id.outputs.result }}"  # <3>
  variableName: "my_state"          # <4>
----

<1> Step ID for this store operation
<2> Descriptive name (optional)
<3> Reference to the source variable/step output
<4> Name to store the state under (required)

==== Parameters

[cols="1,1,2,3"]
|===
|Parameter |Type |Required |Description

|`action`
|string
|Yes
|Must be `"STORE_STATE"`

|`id`
|string
|No
|Step identifier

|`name`
|string
|No
|Human-readable description

|`sourceVariable`
|string
|Yes
|Reference to the value to store (e.g., `${{ steps.step_id.outputs.result }}`)

|`variableName`
|string
|Yes
|Name to identify this stored state
|===

==== Outputs

[cols="1,2,3"]
|===
|Output |Type |Description

|`result`
|string
|Confirmation message

|`storedValue`
|string
|The value that was stored

|`variableName`
|string
|The variable name used

|`status`
|string
|`"success"` if stored successfully
|===

==== Example

[source,yaml]
----
# Capture initial world time
- action: "SERVER_COMMAND"
  id: "initial_time"
  name: "Get initial time"
  command: "time query gametime"

- action: "STORE_STATE"
  id: "store_start_time"
  name: "Store initial time"
  sourceVariable: "${{ steps.initial_time.outputs.result }}"
  variableName: "start_time"

# Perform actions that change time
- action: "SERVER_COMMAND"
  name: "Set time to noon"
  command: "time set noon"

# Capture final world time
- action: "SERVER_COMMAND"
  id: "final_time"
  name: "Get final time"
  command: "time query gametime"

- action: "STORE_STATE"
  id: "store_end_time"
  name: "Store final time"
  sourceVariable: "${{ steps.final_time.outputs.result }}"
  variableName: "end_time"

# Compare states
- action: "COMPARE_STATES"
  name: "Compare time states"
  state1: "start_time"
  state2: "end_time"
----

==== Related Commands

* <<print_stored_state,PRINT_STORED_STATE>> - Print stored state value
* <<compare_states,COMPARE_STATES>> - Compare two stored states
* <<extract_with_jsonpath,EXTRACT_WITH_JSONPATH>> - Extract specific values to store

'''

[[print_stored_state]]
=== PRINT_STORED_STATE

[.lead]
Print the value of a stored state to the test output. Useful for debugging and logging state values during test execution.

==== Syntax

[source,yaml]
----
- action: "PRINT_STORED_STATE"
  id: "unique_step_id"              # <1>
  name: "Human-readable name"       # <2>
  variableName: "my_state"          # <3>
----

<1> Step ID (optional)
<2> Descriptive name (optional)
<3> Name of the stored state to print

==== Parameters

[cols="1,1,2,3"]
|===
|Parameter |Type |Required |Description

|`action`
|string
|Yes
|Must be `"PRINT_STORED_STATE"`

|`id`
|string
|No
|Step identifier

|`name`
|string
|No
|Human-readable description

|`variableName`
|string
|Yes
|Name of the stored state to print
|===

==== Outputs

[cols="1,2,3"]
|===
|Output |Type |Description

|`result`
|string
|The stored value

|`variableName`
|string
|The variable name

|`status`
|string
|`"success"` if found
|===

==== Example

[source,yaml]
----
# Store some state
- action: "SERVER_COMMAND"
  id: "server_info"
  name: "Get server info"
  command: "version"

- action: "EXTRACT_WITH_JSONPATH"
  id: "extract_version"
  name: "Extract server version"
  sourceVariable: "${{ steps.server_info.outputs.result }}"
  jsonPath: "$"
  storeAs: "server_version"

# Print the stored state
- action: "PRINT_STORED_STATE"
  id: "print_version"
  name: "Print server version"
  variableName: "server_version"
----

==== Related Commands

* <<store_state,STORE_STATE>> - Store a state value
* <<print_state_comparison,PRINT_STATE_COMPARISON>> - Print comparison result

'''

[[compare_states]]
=== COMPARE_STATES

[.lead]
Compare two stored states and return the differences. Essential for state comparison tests that verify changes between "before" and "after" snapshots.

==== Syntax

[source,yaml]
----
- action: "COMPARE_STATES"
  id: "unique_step_id"              # <1>
  name: "Human-readable name"       # <2>
  state1: "state_variable_name"     # <3>
  state2: "state_variable_name"     # <4>
----

<1> Step ID for output referencing
<2> Descriptive name (optional)
<3> First state to compare (from `variableName`)
<4> Second state to compare

==== Parameters

[cols="1,1,2,3"]
|===
|Parameter |Type |Required |Description

|`action`
|string
|Yes
|Must be `"COMPARE_STATES"`

|`id`
|string
|No
|Step identifier

|`name`
|string
|No
|Human-readable description

|`state1`
|string
|Yes
|Name of first stored state

|`state2`
|string
|Yes
|Name of second stored state
|===

==== Outputs

[cols="1,2,3"]
|===
|Output |Type |Description

|`result`
|json
|JSON object with comparison details

|`equal`
|boolean
|`true` if states are equal

|`state1_name`
|string
|Name of first state

|`state2_name`
|string
|Name of second state

|`added`
|array
|New elements in state2

|`removed`
|array
|Elements removed from state1

|`changed`
|array
|Elements that changed

|`message`
|string
|Human-readable comparison summary
|===

==== Example

[source,yaml]
----
# Capture inventory before action
- action: "SERVER_COMMAND"
  id: "inventory_before"
  name: "Get inventory before"
  command: "data get entity pilaf_tester Inventory"

- action: "STORE_STATE"
  id: "store_before"
  name: "Store before state"
  sourceVariable: "${{ steps.inventory_before.outputs.result }}"
  variableName: "inventory_before"

# Give player an item
- action: "SERVER_COMMAND"
  name: "Give diamond"
  command: "give pilaf_tester diamond"

# Capture inventory after action
- action: "SERVER_COMMAND"
  id: "inventory_after"
  name: "Get inventory after"
  command: "data get entity pilaf_tester Inventory"

- action: "STORE_STATE"
  id: "store_after"
  name: "Store after state"
  sourceVariable: "${{ steps.inventory_after.outputs.result }}"
  variableName: "inventory_after"

# Compare states
- action: "COMPARE_STATES"
  id: "compare_inventory"
  name: "Compare inventory states"
  state1: "inventory_before"
  state2: "inventory_after"
----

==== Related Commands

* <<store_state,STORE_STATE>> - Store states to compare
* <<print_state_comparison,PRINT_STATE_COMPARISON>> - Print comparison result
* <<extract_with_jsonpath,EXTRACT_WITH_JSONPATH>> - Extract values for comparison

'''

[[print_state_comparison]]
=== PRINT_STATE_COMPARISON

[.lead]
Print the result of a state comparison in a human-readable format. Useful for debugging and logging comparison results.

==== Syntax

[source,yaml]
----
- action: "PRINT_STATE_COMPARISON"
  id: "unique_step_id"              # <1>
  name: "Human-readable name"       # <2>
  fromComparison: "${{ steps.compare_states.outputs.result }}"  # <3>
----

<1> Step ID (optional)
<2> Descriptive name (optional)
<3> Reference to comparison result

==== Parameters

[cols="1,1,2,3"]
|===
|Parameter |Type |Required |Description

|`action`
|string
|Yes
|Must be `"PRINT_STATE_COMPARISON"`

|`id`
|string
|No
|Step identifier

|`name`
|string
|No
|Human-readable description

|`fromComparison`
|string
|Yes
|Reference to comparison result (e.g., `${{ steps.compare_id.outputs.result }}`)
|===

==== Outputs

[cols="1,2,3"]
|===
|Output |Type |Description

|`result`
|string
|Formatted comparison output

|`equal`
|boolean
|Whether states are equal

|`summary`
|string
|Brief summary of differences

|`status`
|string
|`"success"` if printed
|===

==== Example

[source,yaml]
----
# Compare states and print result
- action: "COMPARE_STATES"
  id: "compare"
  name: "Compare inventory"
  state1: "inventory_before"
  state2: "inventory_after"

- action: "PRINT_STATE_COMPARISON"
  id: "print_result"
  name: "Print comparison result"
  fromComparison: "${{ steps.compare.outputs.result }}"
----

==== Related Commands

* <<compare_states,COMPARE_STATES>> - Perform comparison
* <<print_stored_state,PRINT_STORED_STATE>> - Print stored state

'''

[[extract_with_jsonpath]]
=== EXTRACT_WITH_JSONPATH

[.lead]
Extract specific values from JSON data using JSONPath expressions. Essential for accessing nested data in server responses and command outputs.

==== Syntax

[source,yaml]
----
- action: "EXTRACT_WITH_JSONPATH"
  id: "unique_step_id"              # <1>
  name: "Human-readable name"       # <2>
  sourceVariable: "${{ steps.step_id.outputs.result }}"  # <3>
  jsonPath: "$.path.to.value"       # <4>
  storeAs: "variable_name"          # <5>
----

<1> Step ID for output referencing
<2> Descriptive name (optional)
<3> Reference to source JSON data
<4> JSONPath expression to extract
<5> Variable name to store extracted value

==== Parameters

[cols="1,1,2,3"]
|===
|Parameter |Type |Required |Description

|`action`
|string
|Yes
|Must be `"EXTRACT_WITH_JSONPATH"`

|`id`
|string
|No
|Step identifier

|`name`
|string
|No
|Human-readable description

|`sourceVariable`
|string
|Yes
|Reference to source JSON data

|`jsonPath`
|string
|Yes
|JSONPath expression

|`storeAs`
|string
|Yes
|Variable name for extracted value
|===

==== Outputs

[cols="1,2,3"]
|===
|Output |Type |Description

|`result`
|string
|Extracted value

|`extractedValue`
|string
|The extracted value

|`jsonPath`
|string
|The JSONPath used

|`status`
|string
|`"success"` if extracted
|===

==== JSONPath Examples

[cols="1,2"]
|===
|Expression |Description

|`$.x`
|Extract x coordinate from position

|`$.y`
|Extract y coordinate from position

|`$.z`
|Extract z coordinate from position

|`$.items[0]`
|Extract first item from array

|`$.items[0].name`
|Extract name of first item

|`$.entities[0].uuid`
|Extract UUID of first entity

|`$.version`
|Extract version field

|`$..health`
|Recursively find health fields
|===

==== Example

[source,yaml]
----
# Get server info
- action: "SERVER_COMMAND"
  id: "server_info"
  name: "Get server info"
  command: "version"

# Extract version
- action: "EXTRACT_WITH_JSONPATH"
  id: "extract_version"
  name: "Extract version"
  sourceVariable: "${{ steps.server_info.outputs.result }}"
  jsonPath: "$"
  storeAs: "server_version"

# Get player position and extract coordinates
- action: "PLAYER_COMMAND"
  id: "player_pos"
  name: "Get player position"
  player: "pilaf_tester"
  command: "data get entity @s Pos"

- action: "EXTRACT_WITH_JSONPATH"
  id: "extract_x"
  name: "Extract X coordinate"
  sourceVariable: "${{ steps.player_pos.outputs.result }}"
  jsonPath: "$"
  storeAs: "player_x"
----

==== Related Commands

* <<store_state,STORE_STATE>> - Store extracted value
* <<compare_states,COMPARE_STATES>> - Compare extracted values

'''

[[filter_entities]]
=== FILTER_ENTITIES

[.lead]
Filter entities based on specified criteria such as type, name, or custom properties. Useful for finding specific entities among many.

==== Syntax

[source,yaml]
----
- action: "FILTER_ENTITIES"
  id: "unique_step_id"              # <1>
  name: "Human-readable name"       # <2>
  sourceVariable: "${{ steps.get_entities.outputs.result }}"  # <3>
  filterType: "type"                # <4>
  filterValue: "zombie"             # <5>
----

<1> Step ID for output referencing
<2> Descriptive name (optional)
<3> Reference to the source entities data
<4> Filter type: `type`, `name`, `customName`
<5> Value to filter by

==== Parameters

[cols="1,1,2,3"]
|===
|Parameter |Type |Required |Description

|`action`
|string
|Yes
|Must be `"FILTER_ENTITIES"`

|`id`
|string
|No
|Step identifier

|`name`
|string
|No
|Human-readable description

|`sourceVariable`
|string
|Yes
|Reference to entities JSON data

|`filterType`
|string
|Yes
|Filter criterion: `type`, `name`, `customName`, `uuid`

|`filterValue`
|string
|Yes
|Value to match
|===

==== Outputs

[cols="1,2,3"]
|===
|Output |Type |Description

|`result`
|json
|JSON array of matching entities

|`count`
|number
|Number of matching entities

|`entities`
|array
|Array of entity objects

|`status`
|string
|`"success"` if filtered
|===

==== Example

[source,yaml]
----
# Get all entities using selector
- action: "SERVER_COMMAND"
  id: "get_all"
  name: "Get all entities"
  command: "execute as @a run data get entity @e"

# Filter zombies (post-processing)
- action: "FILTER_ENTITIES"
  id: "filter_zombies"
  name: "Filter zombie entities"
  sourceVariable: "${{ steps.get_all.outputs.result }}"
  filterType: "type"
  filterValue: "zombie"
----

==== Related Commands

* <<extract_with_jsonpath,EXTRACT_WITH_JSONPATH>> - Extract from filtered results
* <<assert_response_contains,ASSERT_RESPONSE_CONTAINS>> - Check filter results

'''

[[execute_player_command]]
=== EXECUTE_PLAYER_COMMAND

[.lead]
Execute a command as a connected player through the Mineflayer client. This simulates a player typing a command in chat, which is useful for testing commands that only work when executed by a player.

==== Syntax

[source,yaml]
----
- action: "EXECUTE_PLAYER_COMMAND"
  id: "unique_step_id"              # <1>
  name: "Human-readable name"       # <2>
  player: "player_name"             # <3>
  command: "/home set"              # <4>
----

<1> Step ID for output referencing
<2> Descriptive name (optional)
<3> Player name to execute as
<4> Command to execute (with or without `/`)

==== Parameters

[cols="1,1,2,3"]
|===
|Parameter |Type |Required |Description

|`action`
|string
|Yes
|Must be `"EXECUTE_PLAYER_COMMAND"`

|`id`
|string
|No
|Step identifier

|`name`
|string
|No
|Human-readable description

|`player`
|string
|Yes
|Player name to execute command

|`command`
|string
|Yes
|Command to execute
|===

==== Outputs

[cols="1,2,3"]
|===
|Output |Type |Description

|`result`
|string
|Command response

|`status`
|string
|`"success"` or `"failure"`

|`message`
|string
|Human-readable status message

|`player`
|string
|Player who executed
|===

==== Example

[source,yaml]
----
# Connect player first
- action: "CONNECT_PLAYER"
  name: "Connect test player"
  player: "pilaf_tester"

# Execute player command
- action: "EXECUTE_PLAYER_COMMAND"
  id: "set_home"
  name: "Set home location"
  player: "pilaf_tester"
  command: "/home set"

# Execute home teleport
- action: "EXECUTE_PLAYER_COMMAND"
  id: "go_home"
  name: "Teleport to home"
  player: "pilaf_tester"
  command: "/home"

# Execute plugin command
- action: "EXECUTE_PLAYER_COMMAND"
  id: "plugin_cmd"
  name: "Execute plugin command"
  player: "pilaf_tester"
  command: "/myplugin action"
----

==== Related Commands

* <<execute_player_raw,EXECUTE_PLAYER_RAW>> - Raw command execution
* link:../player-commands.html#connect_player[CONNECT_PLAYER] - Connect player first

'''

[[execute_player_raw]]
=== EXECUTE_PLAYER_RAW

[.lead]
Execute a raw command as a player without any processing. Provides direct access to the player's command channel.

==== Syntax

[source,yaml]
----
- action: "EXECUTE_PLAYER_RAW"
  id: "unique_step_id"              # <1>
  name: "Human-readable name"       # <2>
  player: "player_name"             # <3>
  command: "raw_command_string"     # <4>
----

<1> Step ID for output referencing
<2> Descriptive name (optional)
<3> Player name to execute as
<4> Raw command string to send

==== Parameters

[cols="1,1,2,3"]
|===
|Parameter |Type |Required |Description

|`action`
|string
|Yes
|Must be `"EXECUTE_PLAYER_RAW"`

|`id`
|string
|No
|Step identifier

|`name`
|string
|No
|Human-readable description

|`player`
|string
|Yes
|Player name to execute command

|`command`
|string
|Yes
|Raw command string
|===

==== Outputs

[cols="1,2,3"]
|===
|Output |Type |Description

|`result`
|string
|Raw response from server

|`status`
|string
|`"success"` or `"failure"`

|`message`
|string
|Status message
|===

==== Example

[source,yaml]
----
# Connect player
- action: "CONNECT_PLAYER"
  name: "Connect player"
  player: "pilaf_tester"

# Send raw command with NBT data
- action: "EXECUTE_PLAYER_RAW"
  id: "give_sword"
  name: "Give enchanted sword"
  player: "pilaf_tester"
  command: "give pilaf_tester diamond_sword 1 {ench:[{id:0,lvl:5}]}"
----

[NOTE]
====
Unlike `EXECUTE_PLAYER_COMMAND`, this sends the command exactly as provided without any preprocessing or argument parsing.
====

==== Related Commands

* <<execute_player_command,EXECUTE_PLAYER_COMMAND>> - Command with processing

'''

'''

=== Assertion Commands

Assertion commands validate expected outcomes and ensure test reliability.

[[assert_entity_exists]]
=== ASSERT_ENTITY_EXISTS

[.lead]
Assert that a specific entity exists in the Minecraft world. The entity is identified by its custom name (without the `test_` prefix).

==== Syntax

[source,yaml]
----
- action: "ASSERT_ENTITY_EXISTS"
  name: "Human-readable name"       # <1>
  entity: "entity_name"             # <2>
  expected: true                    # <3>
----

<1> Descriptive name for the assertion
<2> Entity name to check (without `test_` prefix)
<3> Expected existence (optional, default: true)

==== Parameters

[cols="1,1,2,3"]
|===
|Parameter |Type |Required |Description

|`action`
|string
|Yes
|Must be `"ASSERT_ENTITY_EXISTS"`

|`name`
|string
|No
|Human-readable description

|`entity`
|string
|Yes
|Entity name to check

|`expected`
|boolean
|No
|Expected existence (default: true)
|===

==== Result

[cols="1,2,3"]
|===
|Field |Type |Description

|`passed`
|boolean
|`true` if entity exists as expected

|`message`
|string
|Summary message

|`details`
|string
|Entity existence status
|===

==== Example

[source,yaml]
----
# Spawn entity
- action: "SERVER_COMMAND"
  name: "Spawn zombie"
  command: "summon zombie ~ ~ ~ {CustomName:'\"test_zombie\"'}"

# Assert entity exists
- action: "ASSERT_ENTITY_EXISTS"
  name: "Verify zombie spawned"
  entity: "zombie"
----

==== Related Commands

* <<assert_entity_missing,ASSERT_ENTITY_MISSING>> - Assert entity does not exist

'''

[[assert_entity_missing]]
=== ASSERT_ENTITY_MISSING

[.lead]
Assert that a specific entity does not exist in the Minecraft world. The entity is identified by its custom name (with or without the `test_` prefix).

==== Syntax

[source,yaml]
----
- action: "ASSERT_ENTITY_MISSING"
  name: "Human-readable name"       # <1>
  entity: "entity_name"             # <2>
----

<1> Descriptive name for the assertion
<2> Entity name to check

==== Parameters

[cols="1,1,2,3"]
|===
|Parameter |Type |Required |Description

|`action`
|string
|Yes
|Must be `"ASSERT_ENTITY_MISSING"`

|`name`
|string
|No
|Human-readable description

|`entity`
|string
|Yes
|Entity name to check
|===

==== Result

[cols="1,2,3"]
|===
|Field |Type |Description

|`passed`
|boolean
|`true` if entity does not exist

|`message`
|string
|Summary message

|`details`
|string
|Entity existence status
|===

==== Example

[source,yaml]
----
# Assert entity doesn't exist yet
- action: "ASSERT_ENTITY_MISSING"
  name: "Verify no zombie yet"
  entity: "zombie"

# Kill entity
- action: "SERVER_COMMAND"
  name: "Kill zombie"
  command: "kill @e[type=zombie,custom_name=test_zombie]"

# Assert entity is gone
- action: "ASSERT_ENTITY_MISSING"
  name: "Verify zombie gone"
  entity: "zombie"
----

==== Related Commands

* <<assert_entity_exists,ASSERT_ENTITY_EXISTS>> - Assert entity does exist

'''

[[assert_response_contains]]
=== ASSERT_RESPONSE_CONTAINS

[.lead]
Assert that a response string contains expected content. This is a framework-level primitive for validating command outputs.

==== Syntax

[source,yaml]
----
- action: "ASSERT_RESPONSE_CONTAINS"
  name: "Human-readable name"       # <1>
  source: "${{ steps.step_id.outputs.result }}"  # <2>
  contains: "expected_text"          # <3>
----

<1> Descriptive name (optional)
<2> Reference to the response to check
<3> Expected text that must be present

==== Parameters

[cols="1,1,2,3"]
|===
|Parameter |Type |Required |Description

|`action`
|string
|Yes
|Must be `"ASSERT_RESPONSE_CONTAINS"`

|`name`
|string
|No
|Human-readable description

|`source`
|string
|Yes
|Reference to response data

|`contains`
|string
|Yes
|Expected content
|===

==== Result

[cols="1,2,3"]
|===
|Field |Type |Description

|`passed`
|boolean
|`true` if assertion passed

|`message`
|string
|Summary message

|`details`
|string
|Assertion details
|===

==== Example

[source,yaml]
----
# Execute server command
- action: "SERVER_COMMAND"
  id: "version_cmd"
  name: "Get server version"
  command: "version"

# Assert response contains expected text
- action: "ASSERT_RESPONSE_CONTAINS"
  name: "Verify version response"
  source: "${{ steps.version_cmd.outputs.result }}"
  contains: "version"
----

==== Related Commands

* <<assert_json_equals,ASSERT_JSON_EQUALS>> - Assert JSON structure matches

'''

[[assert_json_equals]]
=== ASSERT_JSON_EQUALS

[.lead]
Assert that a JSON response matches an expected structure. This framework primitive validates complex data structures.

==== Syntax

[source,yaml]
----
- action: "ASSERT_JSON_EQUALS"
  name: "Human-readable name"       # <1>
  source: "${{ steps.step_id.outputs.result }}"  # <2>
  expected: '{"key": "value"}'      # <3>
----

<1> Descriptive name (optional)
<2> Reference to JSON response
<3> Expected JSON structure

==== Parameters

[cols="1,1,2,3"]
|===
|Parameter |Type |Required |Description

|`action`
|string
|Yes
|Must be `"ASSERT_JSON_EQUALS"`

|`name`
|string
|No
|Human-readable description

|`source`
|string
|Yes
|Reference to JSON data

|`expected`
|string
|Yes
|Expected JSON structure
|===

==== Result

[cols="1,2,3"]
|===
|Field |Type |Description

|`passed`
|boolean
|`true` if JSON matches

|`message`
|string
|Summary message

|`details`
|string
|Comparison details
|===

==== Example

[source,yaml]
----
# Get server version as JSON
- action: "SERVER_COMMAND"
  id: "version_cmd"
  name: "Get version JSON"
  command: "data get entity @e[type=player,limit=1]"

# Assert JSON structure
- action: "ASSERT_JSON_EQUALS"
  name: "Verify player data structure"
  source: "${{ steps.version_cmd.outputs.result }}"
  expected: '{"id": "test_player"}'
----

==== Related Commands

* <<assert_response_contains,ASSERT_RESPONSE_CONTAINS>> - Assert text content

'''

[[assert_log_contains]]
=== ASSERT_LOG_CONTAINS

[.lead]
Assert that the server logs contain a specific pattern. This is a framework-level primitive for verifying server behavior through log analysis.

==== Syntax

[source,yaml]
----
- action: "ASSERT_LOG_CONTAINS"
  name: "Human-readable name"       # <1>
  pattern: "expected_log_pattern"    # <2>
----

<1> Descriptive name (optional)
<2> Regular expression pattern to match

==== Parameters

[cols="1,1,2,3"]
|===
|Parameter |Type |Required |Description

|`action`
|string
|Yes
|Must be `"ASSERT_LOG_CONTAINS"`

|`name`
|string
|No
|Human-readable description

|`pattern`
|string
|Yes
|Regex pattern to search in logs
|===

==== Result

[cols="1,2,3"]
|===
|Field |Type |Description

|`passed`
|boolean
|`true` if pattern found

|`message`
|string
|Summary message

|`details`
|string
|Match details
|===

==== Example

[source,yaml]
----
# Spawn entity
- action: "SERVER_COMMAND"
  name: "Spawn zombie"
  command: "summon zombie ~ ~ ~ {CustomName:'\"test_zombie\"'}"

# Assert log contains spawn message
- action: "ASSERT_LOG_CONTAINS"
  name: "Verify spawn logged"
  pattern: "Summoned.*Zombie"
----

==== Related Commands

* <<assert_response_contains,ASSERT_RESPONSE_CONTAINS>> - Assert response content

'''

[[assert_condition]]
=== ASSERT_CONDITION

[.lead]
Assert that a custom condition evaluates to true. This is a generic framework primitive for flexible validation logic.

==== Syntax

[source,yaml]
----
- action: "ASSERT_CONDITION"
  name: "Human-readable name"       # <1>
  condition: "${{ variable }} == expected"  # <2>
----

<1> Descriptive name (optional)
<2> Condition expression to evaluate

==== Parameters

[cols="1,1,2,3"]
|===
|Parameter |Type |Required |Description

|`action`
|string
|Yes
|Must be `"ASSERT_CONDITION"`

|`name`
|string
|No
|Human-readable description

|`condition`
|string
|Yes
|Condition to evaluate
|===

==== Result

[cols="1,2,3"]
|===
|Field |Type |Description

|`passed`
|boolean
|`true` if condition is true

|`message`
|string
|Summary message

|`details`
|string
|Condition evaluation result
|===

==== Example

[source,yaml]
----
# Store count
- action: "SERVER_COMMAND"
  id: "count_cmd"
  name: "Count entities"
  command: "execute if entity @e[type=zombie]"

# Assert condition on result
- action: "ASSERT_CONDITION"
  name: "Verify zombie count"
  condition: "${{ steps.count_cmd.outputs.result }} != 0"
----

==== Related Commands

* <<assert_response_contains,ASSERT_RESPONSE_CONTAINS>> - Assert content presence

'''

== Command Summary

[cols="2,3,2"]
|===
|Command |Purpose |Key Outputs

|link:#wait[WAIT]
|Pause test execution
|`duration`, `status`

|link:#store_state[STORE_STATE]
|Store state for later use
|`variableName`, `storedValue`

|link:#compare_states[COMPARE_STATES]
|Compare two stored states
|`equal`, `added`, `removed`

|link:#extract_with_jsonpath[EXTRACT_WITH_JSONPATH]
|Extract values from JSON
|`result`, `extractedValue`

|link:#filter_entities[FILTER_ENTITIES]
|Filter entities by criteria
|`count`, `entities`

|link:#execute_player_command[EXECUTE_PLAYER_COMMAND]
|Execute command as player
|`result`, `status`

|link:#execute_player_raw[EXECUTE_PLAYER_RAW]
|Execute raw player command
|`result`, `status`

|link:#assert_entity_exists[ASSERT_ENTITY_EXISTS]
|Assert entity exists
|`passed`, `details`

|link:#assert_entity_missing[ASSERT_ENTITY_MISSING]
|Assert entity does not exist
|`passed`, `details`

|link:#assert_response_contains[ASSERT_RESPONSE_CONTAINS]
|Assert response content
|`passed`, `details`

|link:#assert_json_equals[ASSERT_JSON_EQUALS]
|Assert JSON structure
|`passed`, `details`

|link:#assert_log_contains[ASSERT_LOG_CONTAINS]
|Assert log pattern
|`passed`, `details`

|link:#assert_condition[ASSERT_CONDITION]
|Assert custom condition
|`passed`, `details`
|===

'''

== See Also

* link:server-commands.html[Server Commands] - Server-side operations
* link:player-commands.html[Player Commands] - Player operations
* link:guides/writing-stories.html[Writing Stories] - How to use commands in stories
