= PILAF: Minecraft Plugin Integration Testing Framework

image:https://img.shields.io/badge/Java-17%2B-blue[Java Version]
image:https://img.shields.io/badge/Gradle-7.6-green[Gradle Version]
image:https://img.shields.io/badge/License-MIT-yellow[License]
image:https://github.com/cavarest/pilaf/actions/workflows/unit-tests.yml/badge.svg["Unit Tests", link="https://github.com/cavarest/pilaf/actions/workflows/unit-tests.yml"]
image:https://github.com/cavarest/pilaf/actions/workflows/integration-tests.yml/badge.svg["Integration Tests", link="https://github.com/cavarest/pilaf/actions/workflows/integration-tests.yml"]

PILAF (Paper Integration Layer for Automation Functions) is a comprehensive YAML
story-driven testing framework specifically designed for PaperMC Minecraft
plugin developers. It transforms complex Java integration tests into simple,
readable YAML scenarios that enable automated testing of Minecraft plugin
functionality.

== Purpose

Traditional Minecraft plugin testing requires extensive Java code to simulate player actions, execute server commands, and validate results. PILAF eliminates this complexity by providing a YAML-based story format that non-developers can understand and maintain.

== Architecture

=== High-Level Flow

.PILAF Testing Architecture
[source]
----
┌─────────────┐    ┌─────────────┐     ┌──────────────┐   ┌─────────────┐
│ YAML Story  │    │   PILAF     │     │   Backend    │   │ Minecraft   │
│             │    │  Framework  │     │  Interface   │   │   Server    │
│ • Setup     │───▶│             │────▶│              │──▶│             │
│ • Steps     │    │ • Parser    │     │ • Mineflayer │   │ • Players   │
│ • Cleanup   │    │ • Executor  │     │ • RCON       │   │ • Commands  │
└─────────────┘    └─────────────┘     └──────────────┘   └─────────────┘
                            │                 │                  │
                            ▼                 ▼                  ▼
                    ┌─────────────┐    ┌──────────────┐   ┌─────────────┐
                    │   State     │    │  Report      │   │   Docker    │
                    │ Management  │    │ Generator    │   │ Orchestrator│
                    │             │    │              │   │             │
                    │ • Variables │    │ • HTML       │   │ • Server    │
                    │ • Compare   │    │ • Screenshots│   │ • Services  │
                    │ • JSONPath  │    │ • Logs       │   │ • Cleanup   │
                    └─────────────┘    └──────────────┘   └─────────────┘
----

=== Core Components

1. **PilafCli**: Standalone command-line interface for running YAML stories
2. **YamlStoryParser**: Parses YAML stories into executable action sequences
3. **TestOrchestrator**: Coordinates execution between backends and state management
4. **Backend Interface**: Abstraction for different testing approaches (Mineflayer, RCON, Mock)
5. **State Management**: Variable storage, comparison, and JSON extraction capabilities
6. **Report Generator**: HTML reports with step-by-step execution logs and screenshots

== Prerequisites

=== System Requirements
- Java 17 or higher
- Gradle 7.6 (wrapper included)
- Docker & Docker Compose (for full integration testing)
- Running PaperMC server or compatible Minecraft server

=== Service Dependencies
PILAF requires these services for full functionality:

1. **PaperMC Server** (localhost:25565)
2. **RCON Server** (localhost:25575)
3. **Mineflayer Bridge** (localhost:3000)

== Installation

=== Using Gradle

Add PILAF to your `build.gradle`:

[source,groovy]
----
dependencies {
    implementation 'org.cavarest:pilaf:0.1.0'
}
----

Note: PILAF is published to GitHub Packages. Ensure you have authentication configured:

[source,groovy]
----
repositories {
    mavenCentral()
    maven {
        url = uri("https://maven.pkg.github.com/cavarest/pilaf")
        credentials {
            username = project.findProperty("gpr.user") ?: System.getenv("GITHUB_ACTOR")
            password = project.findProperty("gpr.key") ?: System.getenv("GITHUB_TOKEN")
        }
    }
}
----

=== Building from Source

[source,shell]
----
./gradlew clean build
----

The JAR file will be generated at `build/libs/pilaf-0.1.0.jar`.

== Testing

This project includes both unit tests and integration tests to ensure code quality and reliability.

=== Unit Tests

Unit tests verify the core functionality without requiring external services:

[source,shell]
----
./gradlew test
----

Unit tests are fast and suitable for local development. Test reports are generated at `build/reports/tests/test/index.html`.

=== Integration Tests

Integration tests verify PILAF works correctly against a real Minecraft server:

[source,shell]
----
./gradlew integrationTest
----

Integration tests require Docker and take longer to run. They are automatically skipped when no Docker daemon is available.

To skip integration tests locally:

[source,shell]
----
SKIP_INTEGRATION_TESTS=true ./gradlew test
----

=== Test Configuration

Tests are organized using JUnit 5 tags:

* *Unit tests*: Tagged with `@Tag("unit")` or no tag, run with `./gradlew test`
* *Integration tests*: Tagged with `@Tag("integration")`, run with `./gradlew integrationTest`

The default `test` task excludes integration tests, ensuring fast local test execution.

=== GitHub Actions Workflows

The project includes the following CI/CD workflows:

[cols="2,3,3"]
|===
| Workflow | Trigger | Purpose

| Unit Tests | On push to main | Runs unit tests on Java 17 and 21

| Integration Tests | On push to main | Tests against Minecraft Paper 1.21.8 server

| Release | Manual, git tag, or GitHub release | Builds, publishes to GitHub Packages, and uploads JAR to GitHub Releases
|===

== Development Workflow

This section describes the development workflow, testing procedures, and release process.

=== Pre-Release Checklist

Before creating a release, ensure all tests pass:

. Run unit tests:
+
[source,shell]
----
./gradlew test
----

. Run integration tests (requires Docker):
+
[source,shell]
----
./gradlew integrationTest
----

. Verify all code quality checks pass:
+
[source,shell]
----
./gradlew check
----

=== Creating a Release

Releases are automated using GitHub Actions. To create a release:

==== Option 1: GitHub Release UI (Recommended)

. Go to https://github.com/cavarest/pilaf/releases/new[new release page]
. Create a new tag (e.g., `v0.1.0`)
. Add release notes (optional)
. Click "Publish release"
. The `Release` workflow will automatically:
  - Build the project
  - Publish to GitHub Packages
  - Upload JAR to GitHub Releases

==== Option 2: Manual Workflow Trigger

. Navigate to https://github.com/cavarest/pilaf/actions/workflows/publish-release.yml[Release workflow]
. Click "Run workflow"
. Enter:
  - `release-version`: e.g., `0.1.0`
  - `post-release-version`: e.g., `0.1.1-SNAPSHOT`
. Click "Run workflow"
. The workflow will:
  - Update version.properties
  - Commit and push changes (creating the tag)
  - Build and publish to GitHub Packages
  - Upload JAR to GitHub Releases

==== Option 3: Push a Git Tag

[source,shell]
----
# Create and push a version tag
git tag v0.1.0
git push origin v0.1.0
----

The `Release` workflow will trigger automatically.

=== Version Management

The project version is defined in `version.properties`. To update the version:

. Edit `version.properties`:
+
[source,properties]
----
version=0.2.0
----

. Commit and tag appropriately

=== Local Build

To build the project locally without running tests:

[source,shell]
----
./gradlew clean build -x test
----

The JAR file will be generated at `build/libs/pilaf-{version}.jar`.

== Quick Start Guide

=== 1. One-Time Setup

Run the setup script to configure the complete PILAF ecosystem:

```bash
# From your plugin root directory
bash lib/pilaf/docker/setup-pilaf.sh
```

This creates:
- `pilaf.jar` - Standalone CLI
- `docker-compose.pilaf.yml` - Docker stack
- `pilaf.yaml` - Configuration file
- Convenience scripts (`start-pilaf-services.sh`, `run-pilaf-tests.sh`, etc.)

=== 2. Create Test Directory Structure

```
src/test/resources/
└── integration-stories/
    ├── lightning-ability-test.yaml
    ├── cooldown-behavior-test.yaml
    └── entity-removal-test.yaml
```

=== 3. Write Your First YAML Story

Create `src/test/resources/integration-stories/my-plugin-test.yaml`:

```yaml
name: "My Plugin Command Test"
description: "Test that /myplugin command works correctly"

setup:
  - action: "execute_rcon_command"
    command: "op test_player"
    name: "Make test player operator"

  - action: "give_item"
    player: "test_player"
    item: "diamond_sword"
    count: 1
    name: "Give test item"

steps:
  - action: "execute_player_command"
    player: "test_player"
    command: "/myplugin test"
    name: "Execute plugin command"

  - action: "wait"
    duration: 1000
    name: "Wait for command response"

  - action: "get_player_inventory"
    player: "test_player"
    store_as: "inventory_after"
    name: "Check inventory after command"

cleanup:
  - action: "execute_rcon_command"
    command: "deop test_player"
    name: "Remove operator privileges"
```

=== 4. Configure PILAF

Edit `pilaf.yaml`:

```yaml
# Backend Configuration
backend: "mineflayer"  # Options: mineflayer, rcon, mock

# Service Connection Settings
mineflayer_url: "http://localhost:3000"
rcon_host: "localhost"
rcon_port: 25575
rcon_password: "dragon123"

# Story Discovery
stories:
  - "src/test/resources/integration-stories/"  # Directory of integration tests
  - "src/test/resources/test-stories/"         # Directory of unit tests

# Reporting
report_directory: "target/pilaf-reports"
verbose: false

# Health Checks
skip_health_checks: false
```

=== 5. Run Your Tests

```bash
# Start services
./start-pilaf-services.sh

# Run tests
./run-pilaf-tests.sh

# Or use CLI directly
java -jar pilaf.jar --config=pilaf.yaml --verbose

# Health check
java -jar pilaf.jar --health-check
```

=== CLI Commands Reference

```bash
# Using config file
java -jar pilaf.jar --config=pilaf.yaml

# Using command line arguments
java -jar pilaf.jar \
  --stories=src/test/resources/integration-stories/ \
  --mineflayer-url=http://localhost:3000 \
  --verbose

# Run specific story files
java -jar pilaf.jar src/test/resources/integration-stories/lightning-ability-test.yaml

# Health check
java -jar pilaf.jar --health-check

# Help
java -jar pilaf.jar --help
```

== YAML Story Writing Guide

=== Story Structure

Every YAML story has three main sections:

```yaml
name: "Story Name"
description: "What this test validates"

setup:           # Actions that run before main test
  - action: "..."

steps:           # Main test execution
  - action: "..."

cleanup:         # Actions that run after test
  - action: "..."
```

=== Action Types Reference

PILAF provides 35+ action types organized by category:

=== Player Management Actions

| Action | Purpose | Required Fields |
|--------|---------|----------------|
| `connect_player` | Connect bot player to server | `player` |
| `disconnect_player` | Disconnect player from server | `player` |
| `make_operator` | Grant operator privileges | `player` |
| `get_player_inventory` | Get player inventory contents | `player`, `store_as` |
| `get_player_position` | Get player coordinates | `player`, `store_as` |
| `get_player_health` | Get player health value | `player`, `store_as` |

=== Entity Management Actions

| Action | Purpose | Required Fields |
|--------|---------|----------------|
| `get_entities_in_view` | Get entities near player | `player`, `store_as` |
| `get_entity_by_name` | Get specific entity data | `entity_name`, `player`, `store_as` |
| `spawn_entity` | Spawn entity at location | `name`, `type`, `location` |
| `get_entity_health` | Get entity health | `entity`, `store_as` |

=== Command Execution Actions

| Action | Purpose | Required Fields |
|--------|---------|----------------|
| `execute_player_command` | Execute command as player | `player`, `command` |
| `execute_rcon_command` | Execute RCON server command | `command` |
| `execute_rcon_with_capture` | Execute RCON with response capture | `command`, `store_as` |

=== State Management Actions

| Action | Purpose | Required Fields |
|--------|---------|----------------|
| `store_state` | Store command result in variable | `variable_name`, `fromCommandResult` |
| `print_stored_state` | Output stored state value | `variable_name` |
| `compare_states` | Compare two stored states | `state1`, `state2`, `store_as` |
| `print_state_comparison` | Output comparison results | `variable_name` |

=== Inventory Management Actions

| Action | Purpose | Required Fields |
|--------|---------|----------------|
| `give_item` | Give item to player | `player`, `item`, `count` |
| `remove_item` | Remove item from player | `player`, `item`, `count` |
| `get_player_equipment` | Get player equipped items | `player`, `store_as` |

=== World & Environment Actions

| Action | Purpose | Required Fields |
|--------|---------|----------------|
| `get_world_time` | Get current world time | `store_as` |
| `get_weather` | Get current weather | `store_as` |
| `wait` | Pause execution | `duration` |

=== Utility Actions

| Action | Purpose | Required Fields |
|--------|---------|----------------|
| `clear_cooldown` | Clear player cooldown | `player` |
| `set_cooldown` | Set player cooldown | `player`, `duration` |
| `clear_entities` | Remove all test entities | - |

=== Advanced Examples

#### State Comparison Workflow

```yaml
steps:
  # Capture entity state before action
  - action: "get_entities_in_view"
    player: "test_player"
    store_as: "entities_before"
    name: "Get entities before lightning"

  # Execute plugin action
  - action: "execute_player_command"
    player: "test_player"
    command: "/lightning strike"
    name: "Use lightning ability"

  # Wait for effect
  - action: "wait"
    duration: 2000
    name: "Wait for lightning processing"

  # Capture state after action
  - action: "get_entities_in_view"
    player: "test_player"
    store_as: "entities_after"
    name: "Get entities after lightning"

  # Compare states
  - action: "compare_states"
    state1: "entities_before"
    state2: "entities_after"
    store_as: "lightning_effect"
    name: "Compare before/after states"

  # Print comparison
  - action: "print_state_comparison"
    variable_name: "lightning_effect"
    name: "Show lightning effect results"
```

#### JSON Data Extraction

```yaml
steps:
  - action: "execute_rcon_with_capture"
    command: "data get entity @e[name=TestZombie,limit=1]"
    store_as: "zombie_data"

  - action: "print_stored_state"
    variable_name: "zombie_data"
    name: "Print raw zombie data"

  # Note: JSONPath extraction requires additional setup
  - action: "extract_with_jsonpath"
    source_variable: "zombie_data"
    json_path: "$.Health"
    store_as: "zombie_health"
    name: "Extract health value using JSONPath"
```

== Backend types

=== Client backend: Mineflayer

For realistic player simulation and full plugin testing:

```yaml
backend: "mineflayer"
```

Features:
* Realistic player behavior simulation
* Chat message capture and processing
* Entity interaction and targeting
* Inventory and equipment management
* Block placement and breaking simulation

Advantages:
* Most realistic testing environment
* Tests actual plugin event handlers
* Captures player feedback and chat responses

=== Client backend: HeadlessMC

For realistic player simulation and full plugin testing:

```yaml
backend: "headlessmc"
```

Features:
* Realistic player behavior simulation
* Chat message capture and processing
* Entity interaction and targeting
* Inventory and equipment management
* Block placement and breaking simulation

Advantages:
* Most realistic testing environment
* Tests actual plugin event handlers
* Captures player feedback and chat responses

=== Server backend: RCON

For server command-focused testing:

```yaml
backend: "rcon"
```

Features:
* Direct server command execution
* Data query and manipulation
* Server state inspection

Use Cases:
* Testing server-side plugin functionality
* Administrative command testing
* Performance testing



== Integration examples

=== Complete Lightning Plugin Test

Based on the DragonEgg Lightning plugin example:

```yaml
name: "Lightning Ability Complete Test"
description: "Test lightning ability with dragon egg requirement"

setup:
  - action: "execute_rcon_command"
    command: "op test_player"
    name: "Grant operator privileges"

  - action: "execute_rcon_command"
    command: "give test_player dragon_egg 1"
    name: "Give dragon egg to player"

  - action: "execute_rcon_command"
    command: "replaceitem entity test_player weapon.offhand dragon_egg 1"
    name: "Equip dragon egg in offhand"

steps:
  # Spawn test entity
  - action: "execute_rcon_command"
    command: "execute at test_player run summon zombie ~ ~5 ~ {CustomName:'\"TestTarget\"'}"
    name: "Spawn zombie target 5 blocks away"

  # Capture state before lightning
  - action: "get_entities_in_view"
    player: "test_player"
    store_as: "entities_before"
    name: "Get entities before lightning"

  - action: "print_stored_state"
    variable_name: "entities_before"
    name: "Print pre-lightning entity state"

  # Execute lightning ability
  - action: "execute_player_command"
    player: "test_player"
    command: "/ability 1"
    name: "Use lightning ability"

  # Wait for effect
  - action: "wait"
    duration: 2000
    name: "Wait for lightning processing"

  # Capture state after lightning
  - action: "get_entities_in_view"
    player: "test_player"
    store_as: "entities_after"
    name: "Get entities after lightning"

  - action: "print_stored_state"
    variable_name: "entities_after"
    name: "Print post-lightning entity state"

  # Compare states to verify entity removal
  - action: "compare_states"
    state1: "entities_before"
    state2: "entities_after"
    store_as: "lightning_result"
    name: "Compare entity states"

  - action: "print_state_comparison"
    variable_name: "lightning_result"
    name: "Show lightning effect comparison"

cleanup:
  - action: "execute_rcon_command"
    command: "kill @e[name=TestTarget]"
    name: "Clean up test entities"

  - action: "execute_rcon_command"
    command: "clear test_player dragon_egg"
    name: "Remove dragon egg from player"

  - action: "execute_rcon_command"
    command: "deop test_player"
    name: "Remove operator privileges"
```

=== Cooldown Testing

Test plugin cooldown functionality:

```yaml
name: "Cooldown Behavior Test"
description: "Test that cooldown blocks immediate reuse"

setup:
  - action: "execute_rcon_command"
    command: "op test_player"
    name: "Grant operator privileges"

  - action: "clear_cooldown"
    player: "test_player"
    name: "Clear any existing cooldown"

steps:
  # Use ability to trigger cooldown
  - action: "execute_player_command"
    player: "test_player"
    command: "/ability 1"
    name: "Use ability to start cooldown"

  - action: "wait"
    duration: 500
    name: "Brief wait"

  # Try to use ability again (should be blocked)
  - action: "execute_player_command"
    player: "test_player"
    command: "/ability 1"
    name: "Attempt ability during cooldown"

  # Wait for cooldown to expire
  - action: "set_cooldown"
    player: "test_player"
    duration: 3000
    name: "Set test cooldown for 3 seconds"

  - action: "execute_player_command"
    player: "test_player"
    command: "/ability 1"
    name: "Use ability after cooldown expires"

cleanup:
  - action: "execute_rcon_command"
    command: "deop test_player"
    name: "Remove operator privileges"
```

== Troubleshooting

=== Common Issues

**Services not available:**
```bash
# Check service status
docker-compose -f docker-compose.pilaf.yml ps

# View logs
docker-compose -f docker-compose.pilaf.yml logs

# Restart services
./stop-pilaf-services.sh
./start-pilaf-services.sh
```

**YAML parsing errors:**
- Check YAML syntax using online validators
- Ensure proper indentation (spaces, not tabs)
- Verify required fields for each action

**Connection timeouts:**
- Verify Docker services
